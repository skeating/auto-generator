#!/usr/bin/env python
#
# @file   writeListOfCode.py
# @brief  Create the code for a list of class
# @author Sarah Keating
#

import sys
import fileHeaders
import generalFunctions
import strFunctions

def writeConstructors(element, package, output):
  element = generalFunctions.writeListOf(element)
  indent = strFunctions.getIndent(element)
  output.write('/*\n' )
  output.write(' * Constructor \n')
  output.write(' */\n')
  output.write('{0}::{0}(unsigned int level, \n'.format(element))
  output.write('  {0}unsigned int version, \n'.format(indent))
  output.write('  {0}unsigned int pkgVersion)\n'.format(indent))
  output.write(' : ListOf(level, version)\n')
  output.write('{\n' )
  output.write('  setSBMLNamespacesAndOwn(new ')
  output.write('{0}PkgNamespaces(level, version, pkgVersion)); \n'.format(package))
  output.write('}\n\n\n')
  output.write('/*\n' )
  output.write(' * Constructor \n')
  output.write(' */\n')
  output.write('{0}::{0}({1}PkgNamespaces* {2}ns)\n '.format(element, package, package.lower()))
  output.write(' : ListOf({0}ns)\n'.format(package.lower()))
  output.write('{\n' )
  output.write('  setElementNamespace({0}ns->getURI());\n'.format(package.lower()))
  output.write('}\n\n\n')
  output.write('/*\n' )
  output.write(' * Returns a deep copy of this {0} \n'.format(element))
  output.write(' */\n')
  output.write('{0}* \n'.format(element))
  output.write('{0}::clone () const\n '.format(element))
  output.write('{\n' )
  output.write('  return new {0}(*this);\n'.format(element))
  output.write('}\n\n\n')
  
def writeGetFunctions(output, element, subelement=False, topelement="", name=""):
  listOf = generalFunctions.writeListOf(element)
  output.write('/*\n')
  if subelement == True:
    output.write(' * Return the nth {0} in the {1} within this {2}.\n'.format(element, listOf, topelement))
    output.write(' */\n')
    output.write('{0}*\n'.format(element))
    output.write('{0}::get{1}(unsigned int n)\n'.format(topelement, element))
    output.write('{\n' )
    output.write('  return m{0}.get(n);\n'.format(name))
    output.write('}\n\n\n')
  else:
    output.write(' * Get a {0} from the {1} by index.\n'.format(element, listOf))
    output.write('*/\n')
    output.write('{0}*\n'.format(element))
    output.write('{0}::get(unsigned int n)\n'.format(listOf))
    output.write('{\n' )
    output.write('  return static_cast<{0}*>(ListOf::get(n));\n'.format(element))
    output.write('}\n\n\n')
  output.write('/*\n')
  if subelement == True:
    output.write(' * Return the nth {0} in the {1} within this {2}.\n'.format(element, listOf, topelement))
    output.write(' */\n')
    output.write('const {0}*\n'.format(element))
    output.write('{0}::get{1}(unsigned int n) const\n'.format(topelement, element))
    output.write('{\n' )
    output.write('  return m{0}.get(n);\n'.format(name))
    output.write('}\n\n\n')
  else:
    output.write(' * Get a {0} from the {1} by index.\n'.format(element, listOf))
    output.write(' */\n')
    output.write('const {0}*\n'.format(element))
    output.write('{0}::get(unsigned int n) const\n'.format(listOf))
    output.write('{\n' )
    output.write('  return static_cast<const {0}*>(ListOf::get(n));\n'.format(element))
    output.write('}\n\n\n')
  output.write('/*\n')
  if subelement == True:
    output.write(' * Return a {0} from the {1} by id.\n'.format(element, listOf))
    output.write(' */\n')
    output.write('{0}*\n'.format(element))
    output.write('{0}::get{1}(const std::string& sid)\n'.format(topelement, element))
    output.write('{\n' )
    output.write('  return m{0}.get(sid);\n'.format(name))
    output.write('}\n\n\n')
  else:
    output.write(' * Get a {0} from the {1} by id.\n'.format(element, listOf))
    output.write(' */\n')
    output.write('{0}*\n'.format(element))
    output.write('{0}::get(const std::string& sid)\n'.format(listOf))
    output.write('{\n' )
    output.write('  return const_cast<{0}*>(\n'.format(element))
    output.write('    static_cast<const {0}&>(*this).get(sid));\n'.format(listOf))
    output.write('}\n\n\n')
  output.write('/*\n')
  if subelement == True:
    output.write(' * Return a {0} from the {1} by id.\n'.format(element, listOf))
    output.write(' */\n')
    output.write('const {0}*\n'.format(element))
    output.write('{0}::get{1}(const std::string& sid) const\n'.format(topelement, element))
    output.write('{\n' )
    output.write('  return m{0}.get(sid);\n'.format(name))
    output.write('}\n\n\n')
  else:
    output.write(' * Get a {0} from the {1} by id.\n'.format(element, listOf))
    output.write(' */\n')
    output.write('const {0}*\n'.format(element))
    output.write('{0}::get(const std::string& sid) const\n'.format(listOf))
    output.write('{\n' )
    output.write('  vector<SBase*>::const_iterator result;\n\n')
    output.write('  result = find_if( mItems.begin(), mItems.end(), IdEq<{0}>(sid) );\n'.format(element))
    output.write('  return (result == mItems.end()) ? 0 : static_cast <{0}*> (*result);\n'.format(element))
    output.write('}\n\n\n')
     
def writeRemoveFunctions(output, element, subelement=False, topelement="", name=""):
  listOf = generalFunctions.writeListOf(element)
  output.write('/*\n')
  if subelement == True:
    output.write(' * Removes the nth {0} from the {1}.\n'.format(element, listOf))
    output.write(' */\n')
    output.write('{0}*\n'.format(element))
    output.write('{0}::remove{1}(unsigned int n)\n'.format(topelement, element))
    output.write('{\n' )
    output.write('  return m{0}.remove(n);\n'.format(name))
    output.write('}\n\n\n')
  else:
    output.write(' * Removes the nth {0} from this {1}\n'.format(element, listOf))
    output.write(' */\n')
    output.write('{0}*\n{1}::remove(unsigned int n)\n'.format(element, listOf))
    output.write('{\n' )
    output.write('  return static_cast<{0}*>(ListOf::remove(n));\n'.format(element))
    output.write('}\n\n\n')
  output.write('/*\n')
  if subelement == True:
    output.write(' * Removes the a {0} with given id from the {1}.\n'.format(element, listOf))
    output.write(' */\n')
    output.write('{0}*\n'.format(element))
    output.write('{0}::remove{1}(const std::string& sid)\n'.format(topelement, element))
    output.write('{\n' )
    output.write('  return m{0}.remove(sid);\n'.format(name))
    output.write('}\n\n\n')
  else:
    output.write(' * Removes the {0} from this {1} with the given identifier\n'.format(element, listOf))
    output.write(' */\n')
    output.write('{0}*\n{1}::remove(const std::string& sid)\n'.format(element, listOf))
    output.write('{\n' )
    output.write('  SBase* item = NULL;\n')
    output.write('  vector<SBase*>::iterator result;\n\n')
    output.write('  result = find_if( mItems.begin(), mItems.end(), IdEq<{0}>(sid) );\n\n'.format(element))
    output.write('  if (result != mItems.end())\n  {\n')
    output.write('    item = *result;\n')
    output.write('    mItems.erase(result);\n  }\n\n')
    output.write('  return static_cast <{0}*> (item);\n'.format(element))
    output.write('}\n\n\n')
     
  
def writeProtectedFunctions(output, element, package):
  listOf = generalFunctions.writeListOf(element)
  generalFunctions.writeInternalStart(output)
  output.write('/*\n')
  output.write(' * Creates a new {0} in this {1}\n'.format(element, listOf))
  output.write(' */\n')
  output.write('SBase*\n{0}::createObject(XMLInputStream& stream)\n'.format(listOf))
  output.write('{\n' )
  output.write('  const std::string& name   = stream.peek().getName();\n')
  output.write('  SBase* object = NULL;\n\n')
  output.write('  if (name == "{0}")\n'.format(strFunctions.lowerFirst(element)))
  output.write('  {\n')
  output.write('    {0}_CREATE_NS({1}ns, getSBMLNamespaces());\n'.format(package.upper(), package.lower()))
  output.write('    object = new {0}({1}ns);\n'.format(element, package.lower()))
  output.write('    appendAndOwn(object);\n')
  output.write('    delete {}ns;\n'.format(package.lower()))
  output.write('  }\n\n')
  output.write('  return object;\n')
  output.write('}\n\n\n')
  generalFunctions.writeInternalEnd(output)
  generalFunctions.writeInternalStart(output)
  output.write('/*\n')
  output.write(' * Write the namespace for the {0} package.\n'.format(package))
  output.write(' */\n')
  output.write('void\n{0}::writeXMLNS(XMLOutputStream& stream) const\n'.format(listOf))
  output.write('{\n' )
  output.write('  XMLNamespaces xmlns;\n\n')
  output.write('  std::string prefix = getPrefix();\n\n')
  output.write('  if (prefix.empty())\n')
  output.write('  {\n')
  output.write('    XMLNamespaces* thisxmlns = getNamespaces();\n')
  output.write('    if (thisxmlns && thisxmlns->hasURI({0}'.format(package))
  output.write('Extension::getXmlnsL3V1V1()))\n')
  output.write('    {\n')
  output.write('      xmlns.add({0}Extension::getXmlnsL3V1V1(),prefix);\n'.format(package))
  output.write('    }\n')
  output.write('  }\n\n')
  output.write('  stream << xmlns;\n')
  output.write('}\n\n\n')
  generalFunctions.writeInternalEnd(output)
  
   
# write the code file      
def createCode(element, code):
  writeConstructors(element['name'], element['package'], code) 
  writeGetFunctions(code, element['name'])
  writeRemoveFunctions(code, element['name'])
  generalFunctions.writeCommonCPPCode(code, element['name'], element['typecode'],None,  True)
  writeProtectedFunctions(code, element['name'], element['package'])

  